<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CloudyPop – Breathing Game</title>
  <!-- Bootstrap CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
  >
  <!-- Bootstrap Icons -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css"
    rel="stylesheet"
  >

  <style>
    :root {
      --bg-dark: #000000;
      --accent: #6c5ce7;
      --accent-soft: rgba(108, 92, 231, 0.35);
      --text-main: #f8f9fa;
      --text-muted: #adb5bd;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: var(--bg-dark);
      color: var(--text-main);
      min-height: 100vh;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    /* Cloud layer */
    .cloud-layer {
      position: fixed;
      inset: 0;
      overflow: hidden;
      z-index: 0;
      pointer-events: none;
      background: radial-gradient(circle at top, #111 0, #000 45%);
    }

    .cloud {
      position: absolute;
      width: 220px;
      height: 110px;
      border-radius: 50%;
      background:
        radial-gradient(circle at 30% 30%, #ffffffee, #ffffff66, #ffffff11);
      filter: blur(3px);
      opacity: 0.5;
      box-shadow:
        -40px 10px 60px #ffffff33,
        40px -5px 80px #ffffff22;
      animation-name: floatCloud;
      animation-timing-function: linear;
      animation-iteration-count: infinite;
    }

    @keyframes floatCloud {
      from {
        transform: translateX(-30vw) translateY(var(--startY, 0));
      }
      to {
        transform: translateX(130vw) translateY(var(--endY, 0));
      }
    }

    /* Foreground / Layout */
    .game-wrapper {
      position: relative;
      z-index: 10;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .game-card {
      background: rgba(0, 0, 0, 0.7);
      border-radius: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 2rem 2.5rem;
      max-width: 520px;
      width: 100%;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(12px);
    }

    .game-title {
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .game-logo {
      font-size: 1.8rem;
      font-weight: 800;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .badge-soft {
      background: var(--accent-soft);
      color: #fff;
      border-radius: 999px;
      padding: 0.15rem 0.6rem;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .main-display {
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
      text-align: center;
    }

    .phase-label {
      font-size: 1rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .phase-label span {
      display: inline-block;
      padding: 0.2rem 0.7rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .timer-value {
      font-size: 10rem;
      font-weight: 800;
      line-height: 1;
      margin-top: 0.2rem;
    }

    .status-text {
      font-size: 0.9rem;
      color: var(--text-muted);
      margin-top: 0.25rem;
      min-height: 1.4em;
    }

    .cycle-counter {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .center-play-btn {
      margin-top: 1.5rem;
    }

    .center-play-btn .btn-lg {
      padding: 0.8rem 2.6rem;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      border-radius: 999px;
    }

    .top-right-controls,
    .bottom-right-controls {
      position: fixed;
      z-index: 20;
      right: 1rem;
      display: flex;
      gap: 0.5rem;
    }

    .top-right-controls {
      top: 1rem;
    }

    .bottom-right-controls {
      bottom: 1rem;
    }

    .icon-btn {
      border-radius: 999px;
      border-width: 1px;
      padding: 0.4rem 0.8rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      font-size: 0.85rem;
    }

    .icon-btn i {
      font-size: 1.1rem;
    }

    .settings-label {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .form-text {
      font-size: 0.8rem;
    }

    .game-over-text {
      font-size: 1.2rem;
      font-weight: 600;
      margin-top: 0.5rem;
    }

    @media (max-width: 576px) {
      .game-card {
        padding: 1.5rem 1.25rem;
      }
      .timer-value {
        font-size: 6rem;
      }
    }
  </style>
</head>
<body>
  <!-- Floating cloud background -->
  <div class="cloud-layer" id="cloudLayer"></div>

  <!-- Settings button (top right) -->
  <div class="top-right-controls">
    <button class="btn btn-outline-light btn-sm icon-btn" id="settingsButton" data-bs-toggle="modal" data-bs-target="#settingsModal">
      <i class="bi bi-gear-fill"></i>
      <span class="d-none d-sm-inline">Settings</span>
    </button>
  </div>

  <!-- Bottom right controls: Play/Pause + Mute -->
  <div class="bottom-right-controls">
    <button class="btn btn-outline-light btn-sm icon-btn" id="playPauseButton">
      <i class="bi bi-play-fill" id="playPauseIcon"></i>
      <span class="d-none d-sm-inline" id="playPauseLabel">Play</span>
    </button>
    <button class="btn btn-outline-light btn-sm icon-btn" id="muteButton">
      <i class="bi bi-volume-up-fill" id="muteIcon"></i>
    </button>
  </div>

  <!-- Main content -->
  <div class="game-wrapper">
    <div class="game-card">
      <div class="d-flex justify-content-between align-items-center">
        <div>
          <div class="game-title">Breathing Game</div>
          <div class="game-logo">CloudyPop</div>
        </div>
        <div>
          <span class="badge-soft">Dark Mode</span>
        </div>
      </div>

      <div class="main-display">
        <div class="phase-label mb-1">
          <span id="phaseLabel">Ready</span>
        </div>
        <div class="timer-value" id="timerValue">0</div>
        <div class="status-text" id="statusText">Press Play to begin a CloudyPop cycle.</div>
        <div class="cycle-counter mt-2">
          Cycle <span id="cycleCurrent">0</span> / <span id="cycleTotal">0</span>
        </div>

        <div class="center-play-btn" id="centerPlayContainer">
          <button class="btn btn-primary btn-lg" id="centerPlayButton">
            <i class="bi bi-play-fill me-1"></i> Play
          </button>
        </div>

        <div id="gameOverContainer" class="mt-3 d-none text-center">
          <div class="game-over-text">Game Over – Max cycles reached.</div>
          <button class="btn btn-outline-light btn-sm mt-2" id="restartButton">
            <i class="bi bi-arrow-repeat me-1"></i> Restart
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal fade" id="settingsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content bg-dark text-light">
        <div class="modal-header border-secondary">
          <h5 class="modal-title">
            <i class="bi bi-sliders me-2"></i> CloudyPop Settings
          </h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <form id="settingsForm">
            <div class="row g-3">
              <!-- Inhale -->
              <div class="col-md-6">
                <div class="settings-label mb-1">Inhale (seconds)</div>
                <div class="row g-2">
                  <div class="col-6">
                    <label class="form-label small mb-0">Min</label>
                    <input type="number" class="form-control form-control-sm" id="inhaleMin" value="4" min="1">
                  </div>
                  <div class="col-6">
                    <label class="form-label small mb-0">Max</label>
                    <input type="number" class="form-control form-control-sm" id="inhaleMax" value="6" min="1">
                  </div>
                </div>
                <div class="form-text">Random inhale time will be between min and max.</div>
              </div>
              <!-- Hold -->
              <div class="col-md-6">
                <div class="settings-label mb-1">Hold (seconds)</div>
                <div class="row g-2">
                  <div class="col-6">
                    <label class="form-label small mb-0">Min</label>
                    <input type="number" class="form-control form-control-sm" id="holdMin" value="4" min="1">
                  </div>
                  <div class="col-6">
                    <label class="form-label small mb-0">Max</label>
                    <input type="number" class="form-control form-control-sm" id="holdMax" value="6" min="1">
                  </div>
                </div>
                <div class="form-text">Hold your breath for a random time in this range.</div>
              </div>

              <!-- Exhale -->
              <div class="col-md-6">
                <div class="settings-label mb-1">Exhale (seconds)</div>
                <div class="row g-2">
                  <div class="col-6">
                    <label class="form-label small mb-0">Min</label>
                    <input type="number" class="form-control form-control-sm" id="exhaleMin" value="4" min="1">
                  </div>
                  <div class="col-6">
                    <label class="form-label small mb-0">Max</label>
                    <input type="number" class="form-control form-control-sm" id="exhaleMax" value="8" min="1">
                  </div>
                </div>
                <div class="form-text">Exhale time will be drawn from this range.</div>
              </div>

              <!-- Break -->
              <div class="col-md-6">
                <div class="settings-label mb-1">Break / Rest (seconds)</div>
                <div class="row g-2">
                  <div class="col-6">
                    <label class="form-label small mb-0">Min</label>
                    <input type="number" class="form-control form-control-sm" id="breakMin" value="3" min="0">
                  </div>
                  <div class="col-6">
                    <label class="form-label small mb-0">Max</label>
                    <input type="number" class="form-control form-control-sm" id="breakMax" value="6" min="0">
                  </div>
                </div>
                <div class="form-text">Short rest after each cycle.</div>
              </div>

              <!-- Delay before cycle -->
              <div class="col-md-6">
                <div class="settings-label mb-1">Delay before each cycle (seconds)</div>
                <div class="row g-2">
                  <div class="col-6">
                    <label class="form-label small mb-0">Min</label>
                    <input type="number" class="form-control form-control-sm" id="delayMin" value="1" min="0">
                  </div>
                  <div class="col-6">
                    <label class="form-label small mb-0">Max</label>
                    <input type="number" class="form-control form-control-sm" id="delayMax" value="3" min="0">
                  </div>
                </div>
                <div class="form-text">“Get ready” time before each new cycle.</div>
              </div>

              <!-- Cycles -->
              <div class="col-md-6">
                <div class="settings-label mb-1">Number of cycles</div>
                <input type="number" class="form-control form-control-sm" id="cycles" value="5" min="1">
                <div class="form-text">Game ends when this many full cycles are completed.</div>
              </div>
            </div>
          </form>
        </div>
        <div class="modal-footer border-secondary">
          <span id="settingsError" class="text-danger me-auto small"></span>
          <button type="button" class="btn btn-outline-light btn-sm" data-bs-dismiss="modal">Close</button>
          <button type="button" class="btn btn-primary btn-sm" id="saveSettingsButton">
            <i class="bi bi-check2-circle me-1"></i> Save
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS Bundle -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    // ===== Local Storage Save/Load =====
function saveSettingsToMemory() {
  const data = {
    inhaleMin: inhaleMinEl.value,
    inhaleMax: inhaleMaxEl.value,
    holdMin: holdMinEl.value,
    holdMax: holdMaxEl.value,
    exhaleMin: exhaleMinEl.value,
    exhaleMax: exhaleMaxEl.value,
    breakMin: breakMinEl.value,
    breakMax: breakMaxEl.value,
    delayMin: delayMinEl.value,
    delayMax: delayMaxEl.value,
    cycles: cyclesEl.value
  };
  localStorage.setItem("cloudyPopSettings", JSON.stringify(data));
}

function loadSettingsFromMemory() {
  const raw = localStorage.getItem("cloudyPopSettings");
  if (!raw) return;
  try {
    const data = JSON.parse(raw);
    inhaleMinEl.value = data.inhaleMin ?? inhaleMinEl.value;
    inhaleMaxEl.value = data.inhaleMax ?? inhaleMaxEl.value;
    holdMinEl.value = data.holdMin ?? holdMinEl.value;
    holdMaxEl.value = data.holdMax ?? holdMaxEl.value;
    exhaleMinEl.value = data.exhaleMin ?? exhaleMinEl.value;
    exhaleMaxEl.value = data.exhaleMax ?? exhaleMaxEl.value;
    breakMinEl.value = data.breakMin ?? breakMinEl.value;
    breakMaxEl.value = data.breakMax ?? breakMaxEl.value;
    delayMinEl.value = data.delayMin ?? delayMinEl.value;
    delayMaxEl.value = data.delayMax ?? delayMaxEl.value;
    cyclesEl.value = data.cycles ?? cyclesEl.value;
  } catch(e) {
    console.warn("Settings corrupted, using defaults.");
  }
}

    // ===== Cloud generator =====
    function createClouds() {
      const layer = document.getElementById('cloudLayer');
      const cloudCount = 14;

      for (let i = 0; i < cloudCount; i++) {
        const cloud = document.createElement('div');
        cloud.className = 'cloud';

        const startY = Math.random() * 80; // vh
        const endY = startY + (Math.random() * 10 - 5);

        cloud.style.setProperty('--startY', startY + 'vh');
        cloud.style.setProperty('--endY', endY + 'vh');

        const scale = 0.6 + Math.random() * 0.8;
        cloud.style.transform = 'scale(' + scale.toFixed(2) + ')';
        cloud.style.top = startY + 'vh';

        const duration = 40 + Math.random() * 50; // seconds
        const delay = Math.random() * -60; // negative for stagger
        cloud.style.animationDuration = duration + 's';
        cloud.style.animationDelay = delay + 's';

        layer.appendChild(cloud);
      }
    }

    // ===== Game state =====
    const state = {
      isPlaying: false,
      isPaused: false,
      currentStage: null,  // "delay" | "inhale" | "hold" | "exhale" | "break"
      currentCycle: 0,
      timeLeft: 0,
      timerId: null,
      wheelTimerId: null,
      muted: false,
      settings: {
        inhaleMin: 4,
        inhaleMax: 6,
        holdMin: 4,
        holdMax: 6,
        exhaleMin: 4,
        exhaleMax: 8,
        breakMin: 3,
        breakMax: 6,
        delayMin: 1,
        delayMax: 3,
        cycles: 5
      }
    };

    // ===== Elements =====
    const phaseLabelEl = document.getElementById('phaseLabel');
    const timerValueEl = document.getElementById('timerValue');
    const statusTextEl = document.getElementById('statusText');
    const cycleCurrentEl = document.getElementById('cycleCurrent');
    const cycleTotalEl = document.getElementById('cycleTotal');
    const centerPlayContainerEl = document.getElementById('centerPlayContainer');
    const centerPlayButtonEl = document.getElementById('centerPlayButton');
    const gameOverContainerEl = document.getElementById('gameOverContainer');
    const restartButtonEl = document.getElementById('restartButton');
    const playPauseButtonEl = document.getElementById('playPauseButton');
    const playPauseIconEl = document.getElementById('playPauseIcon');
    const playPauseLabelEl = document.getElementById('playPauseLabel');
    const muteButtonEl = document.getElementById('muteButton');
    const muteIconEl = document.getElementById('muteIcon');

    const settingsErrorEl = document.getElementById('settingsError');

    // Settings inputs
    const inhaleMinEl = document.getElementById('inhaleMin');
    const inhaleMaxEl = document.getElementById('inhaleMax');
    const holdMinEl = document.getElementById('holdMin');
    const holdMaxEl = document.getElementById('holdMax');
    const exhaleMinEl = document.getElementById('exhaleMin');
    const exhaleMaxEl = document.getElementById('exhaleMax');
    const breakMinEl = document.getElementById('breakMin');
    const breakMaxEl = document.getElementById('breakMax');
    const delayMinEl = document.getElementById('delayMin');
    const delayMaxEl = document.getElementById('delayMax');
    const cyclesEl = document.getElementById('cycles');
    const saveSettingsButtonEl = document.getElementById('saveSettingsButton');

    // ===== Utility =====
    function randint(min, max) {
      min = Math.floor(min);
      max = Math.floor(max);
      if (max < min) [min, max] = [max, min];
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function setPhaseLabel(text) {
      phaseLabelEl.textContent = text;
    }

    function setTimerValue(val) {
      timerValueEl.textContent = val;
    }

    function setStatus(text) {
      statusTextEl.textContent = text;
    }

    function clearTimers() {
      if (state.timerId) {
        clearInterval(state.timerId);
        state.timerId = null;
      }
      if (state.wheelTimerId) {
        clearInterval(state.wheelTimerId);
        state.wheelTimerId = null;
      }
    }

    // ===== Beep sound (no audio files; using Web Audio API) =====
    function playBeep() {
      if (state.muted) return;
      try {
        if (!playBeep.audioCtx) {
          playBeep.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        const ctx = playBeep.audioCtx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.type = 'square';
        osc.frequency.value = 880; // Hz
        gain.gain.value = 0.12;

        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.start();
        osc.stop(ctx.currentTime + 0.16);
      } catch (e) {
        // ignore audio errors
      }
    }

    // ===== Settings handling =====
    function loadSettingsFromForm() {
      const s = {
        inhaleMin: Number(inhaleMinEl.value) || 1,
        inhaleMax: Number(inhaleMaxEl.value) || 1,
        holdMin: Number(holdMinEl.value) || 1,
        holdMax: Number(holdMaxEl.value) || 1,
        exhaleMin: Number(exhaleMinEl.value) || 1,
        exhaleMax: Number(exhaleMaxEl.value) || 1,
        breakMin: Number(breakMinEl.value) || 0,
        breakMax: Number(breakMaxEl.value) || 0,
        delayMin: Number(delayMinEl.value) || 0,
        delayMax: Number(delayMaxEl.value) || 0,
        cycles: Number(cyclesEl.value) || 1
      };

      const pairs = [
        ['Inhale', s.inhaleMin, s.inhaleMax],
        ['Hold', s.holdMin, s.holdMax],
        ['Exhale', s.exhaleMin, s.exhaleMax],
        ['Break', s.breakMin, s.breakMax],
        ['Delay', s.delayMin, s.delayMax]
      ];

      for (const [name, mn, mx] of pairs) {
        if (mn < 0 || mx < 0) {
          settingsErrorEl.textContent = name + ' times cannot be negative.';
          return null;
        }
        if (mx < mn) {
          settingsErrorEl.textContent = name + ' max must be ≥ min.';
          return null;
        }
      }

      if (s.cycles < 1) {
        settingsErrorEl.textContent = 'Number of cycles must be at least 1.';
        return null;
      }

      settingsErrorEl.textContent = '';
      return s;
    }

    function applySettings() {
      const newSettings = loadSettingsFromForm();
      if (!newSettings) return false;
      state.settings = newSettings;
      cycleTotalEl.textContent = state.settings.cycles;
      return true;
    }

    // ===== Wheel of fortune time picker =====
    function spinForRandomTime(min, max, label, doneCallback) {
      clearTimers();
      min = Math.max(0, Math.floor(min));
      max = Math.max(0, Math.floor(max));
      if (max < min) [min, max] = [max, min];

      const finalValue = randint(min, max);

      setPhaseLabel(label.toUpperCase());
      setStatus('Spinning for a random time…');
      let spins = 0;
      state.wheelTimerId = setInterval(() => {
        spins++;
        const fake = randint(min, max);
        setTimerValue(fake + 's');

        // Ramp up the feeling by slowing the interval after some spins
      }, 70);

      // progressively slow + end
      setTimeout(() => {
        clearInterval(state.wheelTimerId);
        state.wheelTimerId = null;
        setTimerValue(finalValue);
        setStatus('Locking in ' + finalValue + ' seconds.');
        setTimeout(() => {
          doneCallback(finalValue);
        }, 400);
      }, 900 + Math.random() * 1000); // 0.9–1.9s spin
    }

    // ===== Timer for each phase =====
    function startPhase(phaseName, duration) {
      clearTimers();
      state.currentStage = phaseName;
      state.timeLeft = duration;

      let labelText;
      let statusHint;

      switch (phaseName) {
        case 'delay':
          labelText = 'Get Ready';
          statusHint = 'Next cycle is about to begin.';
          break;
        case 'inhale':
          labelText = 'Inhale';
          statusHint = 'Slow deep breath in…';
          break;
        case 'hold':
          labelText = 'Hold';
          statusHint = 'Hold gently, stay relaxed.';
          break;
        case 'exhale':
          labelText = 'Exhale';
          statusHint = 'Breathe out smoothly.';
          break;
        case 'break':
          labelText = 'Break';
          statusHint = 'Rest and drift with the clouds.';
          break;
        default:
          labelText = 'Phase';
          statusHint = '';
      }

      setPhaseLabel(labelText.toUpperCase());
      setTimerValue(state.timeLeft);
      setStatus(statusHint);
      playBeep();

      state.timerId = setInterval(() => {
        if (!state.isPlaying || state.isPaused) return;
        state.timeLeft -= 1;
        if (state.timeLeft < 0) state.timeLeft = 0;
        setTimerValue(state.timeLeft);

        if (state.timeLeft <= 0) {
          clearInterval(state.timerId);
          state.timerId = null;
          advancePhase();
        }
      }, 1000);
    }

    // ===== Phase & cycle logic =====
    function advancePhase() {
      const s = state.settings;
      const stage = state.currentStage;

      if (!state.isPlaying) return;

      if (stage === 'delay') {
        // After delay → Inhale
        spinForRandomTime(s.inhaleMin, s.inhaleMax, 'Inhale', (val) => {
          startPhase('inhale', val);
        });
      } else if (stage === 'inhale') {
        // Inhale → Hold
        spinForRandomTime(s.holdMin, s.holdMax, 'Hold', (val) => {
          startPhase('hold', val);
        });
      } else if (stage === 'hold') {
        // Hold → Exhale
        spinForRandomTime(s.exhaleMin, s.exhaleMax, 'Exhale', (val) => {
          startPhase('exhale', val);
        });
      } else if (stage === 'exhale') {
        // Exhale → Break
        if (s.breakMax > 0) {
          spinForRandomTime(s.breakMin, s.breakMax, 'Break', (val) => {
            if (val === 0) {
              // Skip trivial break
              startNextCycleOrEnd();
            } else {
              startPhase('break', val);
            }
          });
        } else {
          startNextCycleOrEnd();
        }
      } else if (stage === 'break') {
        // Break → Next cycle or end
        startNextCycleOrEnd();
      } else {
        startNextCycleOrEnd();
      }
    }

    function startNextCycleOrEnd() {
      const s = state.settings;
      if (state.currentCycle >= s.cycles) {
        endGame();
        return;
      }
      state.currentCycle += 1;
      cycleCurrentEl.textContent = state.currentCycle;

      // Delay before cycle
      if (s.delayMax > 0) {
        spinForRandomTime(s.delayMin, s.delayMax, 'Get Ready', (val) => {
          startPhase('delay', val);
        });
      } else {
        // No delay → straight to inhale
        spinForRandomTime(s.inhaleMin, s.inhaleMax, 'Inhale', (val) => {
          startPhase('inhale', val);
        });
      }
    }

    function startGame() {
      if (!applySettings()) return;

      clearTimers();
      state.isPlaying = true;
      state.isPaused = false;
      state.currentCycle = 0;
      state.currentStage = null;
      gameOverContainerEl.classList.add('d-none');
      centerPlayContainerEl.classList.add('d-none');
      cycleTotalEl.textContent = state.settings.cycles;
      cycleCurrentEl.textContent = 0;

      setStatus('Spinning up your first CloudyPop cycle…');
      setTimerValue('—');
      setPhaseLabel('READY');

      updatePlayPauseButton();

      // Kick off cycle progression
      startNextCycleOrEnd();
    }

    function pauseGame() {
      if (!state.isPlaying) return;
      state.isPaused = true;
      setStatus('Paused. Press Play to resume.');
      updatePlayPauseButton();
    }

    function resumeGame() {
      if (!state.isPlaying) return;
      state.isPaused = false;
      setStatus('Back in the clouds.');
      updatePlayPauseButton();
    }

    function endGame() {
      clearTimers();
      state.isPlaying = false;
      state.isPaused = false;
      setPhaseLabel('GAME OVER');
      setStatus('You finished all your CloudyPop cycles.');
      setTimerValue('0');
      gameOverContainerEl.classList.remove('d-none');
      centerPlayContainerEl.classList.remove('d-none');
      updatePlayPauseButton();
    }

    function updatePlayPauseButton() {
      if (!state.isPlaying) {
        playPauseIconEl.className = 'bi bi-play-fill';
        playPauseLabelEl.textContent = 'Play';
        return;
      }

      if (state.isPaused) {
        playPauseIconEl.className = 'bi bi-play-fill';
        playPauseLabelEl.textContent = 'Resume';
      } else {
        playPauseIconEl.className = 'bi bi-pause-fill';
        playPauseLabelEl.textContent = 'Pause';
      }
    }

    // ===== Event listeners =====
    centerPlayButtonEl.addEventListener('click', () => {
      startGame();
    });

    restartButtonEl.addEventListener('click', () => {
      startGame();
    });

    playPauseButtonEl.addEventListener('click', () => {
      if (!state.isPlaying) {
        startGame();
      } else if (state.isPaused) {
        resumeGame();
      } else {
        pauseGame();
      }
    });

    muteButtonEl.addEventListener('click', () => {
      state.muted = !state.muted;
      if (state.muted) {
        muteIconEl.className = 'bi bi-volume-mute-fill';
      } else {
        muteIconEl.className = 'bi bi-volume-up-fill';
        playBeep();
      }
    });

saveSettingsButtonEl.addEventListener('click', () => {
  if (applySettings()) {
    saveSettingsToMemory();  // <-- NEW
    const modalEl = document.getElementById('settingsModal');
    const modal = bootstrap.Modal.getInstance(modalEl);
    if (modal) modal.hide();
  }
});


    // ===== Init =====
window.addEventListener('DOMContentLoaded', () => {
  createClouds();
  loadSettingsFromMemory();  // <-- NEW
  applySettings();
  setPhaseLabel('READY');
  setTimerValue('0');
  setStatus('Press Play to begin a CloudyPop cycle.');
});

  </script>
</body>
</html>
